<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tunnel Rush 3D — Single File</title>
<style>
  :root{ --bg:#050814; --panel:rgba(255,255,255,0.03); --accent:#6fe7ff; --danger:#ff6b6b; --text:#e8f7ff; }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto; background:linear-gradient(180deg,#02030a,#07102a); color:var(--text);}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:22px;}
  .card{width:100%;max-width:980px;border-radius:12px;padding:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 40px rgba(0,0,0,0.6);}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  h1{font-size:18px;margin:0}
  .meta{font-size:13px;opacity:0.85}
  .game-area{display:grid;grid-template-columns:1fr 260px;gap:12px;}
  @media(max-width:820px){.game-area{grid-template-columns:1fr}}
  .panel{background:var(--panel);border-radius:10px;padding:10px;display:flex;flex-direction:column;align-items:center}
  canvas{width:100%;height:520px;border-radius:8px;display:block;background:radial-gradient(ellipse at 50% 20%, rgba(110,231,255,0.03), transparent 10%), #051024;}
  .controls{display:flex;flex-direction:column;gap:8px;margin-top:10px;width:100%}
  .btn-row{display:flex;gap:8px}
  button{flex:1;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text);font-weight:700;cursor:pointer}
  button.primary{background:linear-gradient(90deg,var(--accent),#2ea6ff);color:#021426;border:0}
  .stat{padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);margin-bottom:8px}
  .big{font-size:28px;font-weight:800;color:var(--accent);text-align:center}
  .small{font-size:13px;opacity:0.9}
  footer{margin-top:10px;font-size:12px;text-align:center;opacity:0.7}
  .touch-ctrls{display:none;margin-top:8px;gap:8px}
  @media(max-width:600px){.touch-ctrls{display:flex} canvas{height:420px}}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <div>
          <h1>Tunnel Rush 3D</h1>
          <div class="meta">Hindari rintangan dalam terowongan 3D. Lebih lama bertahan = skor tinggi.</div>
        </div>
        <div class="meta">Single-file • No libs</div>
      </header>

      <div class="game-area">
        <div class="panel">
          <canvas id="c" width="900" height="520"></canvas>

          <div style="width:100%;display:flex;justify-content:center;margin-top:8px;gap:8px">
            <button id="leftBtn">◀</button>
            <button id="rightBtn">▶</button>
            <button id="pauseBtn">Pause</button>
            <button id="muteBtn">Mute</button>
          </div>

          <div class="touch-ctrls">
            <button id="tleft">Geser Kiri</button>
            <button id="tright">Geser Kanan</button>
          </div>
        </div>

        <div>
          <div class="stat"><div class="small">Score</div><div id="score" class="big">0</div></div>
          <div class="stat"><div class="small">Highscore</div><div id="high" class="big">0</div></div>
          <div class="stat"><div class="small">Speed / Level</div><div id="level" class="big">1</div></div>

          <div style="margin-top:8px" class="stat">
            <div class="small">Kontrol</div>
            <div class="small" style="margin-top:6px">← → atau A/D. Sentuh tombol untuk mobile. Klik kanvas juga bisa start.</div>
          </div>

          <div style="display:flex;gap:8px;margin-top:10px">
            <button id="start" class="primary">Start</button>
            <button id="restart">Restart</button>
          </div>
        </div>
      </div>

      <footer>Buatan mas akbar — Tunnel Rush 3D. Simpan sebagai <code>tunnel-rush-3d.html</code> lalu buka di browser.</footer>
    </div>
  </div>

<script>
/*
 Tunnel Rush 3D — single-file
 Simple pseudo-3D perspective using z-depth projection.
 Obstacles are boxes moving towards camera. Player moves left/right in tunnel.
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// DPI scaling
function DPR(){
  const r = window.devicePixelRatio || 1;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width = Math.floor(W * r);
  canvas.height = Math.floor(H * r);
  ctx.setTransform(r,0,0,r,0,0);
}
DPR();

// UI
const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');
const levelEl = document.getElementById('level');

let highscore = Number(localStorage.getItem('tr_high') || 0);
highEl.textContent = highscore;

// Game state
let running = false, paused = false, mute = false;
let last = 0;
let score = 0;
let level = 1;
let speed = 0.9; // base forward speed
let obstacles = [];
let spawnTimer = 0;
let spawnRate = 900; // ms
let laneCount = 5; // number of horizontal lanes
let laneWidth = 160; // virtual lane width

// Camera / projection
const f = 420; // focal length
const cameraZ = -80; // camera offset
const tunnelRadius = 240; // radius for lane spread

// Player
const player = {
  lane: Math.floor(laneCount/2),
  size: 36
};

// input
const keys = {left:false,right:false};

// helpers
function lerp(a,b,t){return a + (b-a)*t}

// 3D -> 2D projection
function project(x,y,z){
  // camera facing +z; z should be positive distance from camera
  const Z = z + cameraZ + 800; // shift so obstacles start far
  const s = f / (f + Z);
  const px = W/2 + x * s;
  const py = H/2 + y * s;
  const scale = s;
  return {x:px, y:py, s:scale, Z};
}

// spawn obstacle
function spawn(){
  // pick lane randomly, avoid always center
  const lane = Math.floor(Math.random()*laneCount);
  // size variation
  const w = 60 + Math.random()*80;
  const h = 40 + Math.random()*80;
  // z start far
  const z = 2200 + Math.random()*400;
  obstacles.push({lane, w, h, z, hit:false});
}

// draw a 3D box (faux) at lane position
function drawObstacle(o, t){
  const angle = (o.lane - (laneCount-1)/2) * (2*tunnelRadius/(laneCount-1));
  const x = angle;
  const y = 0;
  const proj = project(x, y, o.z);
  if(proj.s <= 0) return;
  const w = o.w * proj.s;
  const h = o.h * proj.s;
  const alpha = Math.min(1, Math.max(0, (2200 - o.z) / 600));
  // simple shading based on Z
  ctx.save();
  ctx.globalAlpha = alpha;
  // shadow/back
  ctx.fillStyle = `rgba(10,30,60,${0.25*alpha})`;
  ctx.fillRect(proj.x - w/2, proj.y - h/2, w, h);
  // face
  const grd = ctx.createLinearGradient(proj.x - w/2, proj.y - h/2, proj.x + w/2, proj.y + h/2);
  grd.addColorStop(0, '#c8dff8');
  grd.addColorStop(1, '#7aa6ff');
  ctx.fillStyle = grd;
  ctx.fillRect(proj.x - w/2, proj.y - h/2, w, h);
  // outline
  ctx.strokeStyle = 'rgba(5,10,20,0.6)';
  ctx.lineWidth = Math.max(1, 1.5*proj.s);
  ctx.strokeRect(proj.x - w/2, proj.y - h/2, w, h);
  ctx.restore();
}

// draw tunnel grid for depth cues
function drawTunnel(t){
  ctx.save();
  ctx.lineWidth = 1;
  for(let i=0;i<40;i++){
    const z = i * 200;
    const size = 1400 - z;
    const s = f / (f + z + cameraZ + 800);
    const radius = tunnelRadius * s;
    ctx.strokeStyle = 'rgba(120,160,220,' + (0.03 + i*0.006) + ')';
    ctx.beginPath();
    ctx.ellipse(W/2, H/2, radius + 260*s, radius, 0, 0, Math.PI*2);
    ctx.stroke();
  }
  // lane separators
  for(let l=0;l<laneCount;l++){
    const laneX = (l - (laneCount-1)/2) * (2*tunnelRadius/(laneCount-1));
    // project two z points to draw line
    const p1 = project(laneX,0,800);
    const p2 = project(laneX,0,2400);
    ctx.strokeStyle = 'rgba(80,120,180,0.06)';
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y-600*p1.s);
    ctx.lineTo(p2.x, p2.y+600*p2.s);
    ctx.stroke();
  }
  ctx.restore();
}

// draw player ship as simple triangle at near plane
function drawPlayer(){
  const laneX = (player.lane - (laneCount-1)/2) * (2*tunnelRadius/(laneCount-1));
  const proj = project(laneX, 80, 90); // near z
  const px = proj.x, py = proj.y;
  const size = 40;
  ctx.save();
  ctx.translate(px, py);
  ctx.rotate(0);
  // glow
  ctx.fillStyle = 'rgba(110,231,255,0.06)';
  ctx.beginPath();
  ctx.ellipse(0, 10, 48, 20, 0, 0, Math.PI*2);
  ctx.fill();
  // ship
  ctx.fillStyle = '#6fe7ff';
  ctx.beginPath();
  ctx.moveTo(0, -size*0.8);
  ctx.lineTo(-size*0.8, size*0.9);
  ctx.lineTo(size*0.8, size*0.9);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#021426';
  ctx.beginPath();
  ctx.ellipse(0, -6, size*0.28, size*0.18, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

// check collision: when obstacle projected box overlaps player region and z small
function checkCollisions(){
  for(let o of obstacles){
    if(o.hit) continue;
    if(o.z < 220){ // near enough to collide
      const laneX = (o.lane - (laneCount-1)/2) * (2*tunnelRadius/(laneCount-1));
      const pObstacle = project(laneX, 0, o.z);
      const w = o.w * pObstacle.s;
      const h = o.h * pObstacle.s;
      const playerLaneX = (player.lane - (laneCount-1)/2) * (2*tunnelRadius/(laneCount-1));
      const pPlayer = project(playerLaneX, 80, 90);
      const pw = 64 * pPlayer.s;
      const ph = 64 * pPlayer.s;
      // simple AABB
      const ax1 = pObstacle.x - w/2, ay1 = pObstacle.y - h/2, ax2 = ax1 + w, ay2 = ay1 + h;
      const bx1 = pPlayer.x - pw/2, by1 = pPlayer.y - ph/2, bx2 = bx1 + pw, by2 = by1 + ph;
      if(!(ax2 < bx1 || ax1 > bx2 || ay2 < by1 || ay1 > by2)){
        return true;
      }
    }
  }
  return false;
}

// audio beep
const audioCtx = (window.AudioContext||window.webkitAudioContext) ? new (window.AudioContext||window.webkitAudioContext)() : null;
function beep(freq=600, dur=0.06, vol=0.04){
  if(mute || !audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sawtooth'; o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

// main loop
function update(ts){
  if(!running || paused) { last = ts; return; }
  if(!last) last = ts;
  const dt = ts - last;
  last = ts;

  // player input movement smoothing
  if(keys.left) player.lane = Math.max(0, player.lane - 0.12 * Math.max(1, dt/16));
  if(keys.right) player.lane = Math.min(laneCount-1, player.lane + 0.12 * Math.max(1, dt/16));
  // allow keyboard discrete changes too (handled in keydown for snappy movement)

  // advance obstacles
  const forward = speed + level*0.08;
  for(let i=obstacles.length-1;i>=0;i--){
    const o = obstacles[i];
    o.z -= forward * (dt*0.6);
    if(o.z < -200) obstacles.splice(i,1);
  }

  // spawn
  spawnTimer += dt;
  const interval = Math.max(380, spawnRate - level*30);
  if(spawnTimer > interval){
    spawnTimer = 0;
    spawn();
    // small chance spawn double
    if(Math.random() < Math.min(0.25, 0.02 + level*0.01)){
      spawn();
    }
  }

  // score and level up
  score += dt*0.02*(1 + level*0.12);
  const newLevel = 1 + Math.floor(score/220);
  if(newLevel !== level){
    level = newLevel;
    beep(700 + Math.random()*200, 0.06, 0.03);
  }
  scoreEl.textContent = Math.floor(score);
  levelEl.textContent = level;

  // check collisions
  if(checkCollisions()){
    // game over
    running = false;
    beep(120,0.2,0.12);
    gameOver();
    return;
  }
}

function render(ts){
  // clear
  ctx.clearRect(0,0,W,H);

  // background subtle gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#041026');
  g.addColorStop(1,'#00121b');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // tunnel grid
  drawTunnel(ts);

  // obstacles sorted by z descending to paint far to near
  const sorted = obstacles.slice().sort((a,b)=> b.z - a.z);
  for(let o of sorted) drawObstacle(o, ts);

  // player
  drawPlayer();

  // HUD small top-left
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(12,12,160,36);
  ctx.fillStyle = '#dff7ff';
  ctx.font = '14px sans-serif';
  ctx.fillText('Score: ' + Math.floor(score), 20, 36);
}

function loop(ts){
  update(ts);
  render(ts);
  if(running) requestAnimationFrame(loop);
}

// start/restart/pause
document.getElementById('start').addEventListener('click', startGame);
document.getElementById('restart').addEventListener('click', restartGame);
document.getElementById('pauseBtn').addEventListener('click', togglePause);
document.getElementById('muteBtn').addEventListener('click', toggleMute);

// keyboard
document.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') { keys.left = true; player.lane = Math.max(0, Math.round(player.lane)-1); }
  if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') { keys.right = true; player.lane = Math.min(laneCount-1, Math.round(player.lane)+1); }
  if(e.key===' '){ togglePause(); }
});
document.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') keys.left = false;
  if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') keys.right = false;
});

// on-screen buttons
document.getElementById('leftBtn').addEventListener('mousedown', ()=>{ player.lane = Math.max(0, Math.round(player.lane)-1); });
document.getElementById('rightBtn').addEventListener('mousedown', ()=>{ player.lane = Math.min(laneCount-1, Math.round(player.lane)+1); });
document.getElementById('leftBtn').addEventListener('touchstart', (e)=>{ e.preventDefault(); player.lane = Math.max(0, Math.round(player.lane)-1); });
document.getElementById('rightBtn').addEventListener('touchstart', (e)=>{ e.preventDefault(); player.lane = Math.min(laneCount-1, Math.round(player.lane)+1); });

// mobile touch controls
document.getElementById('tleft')?.addEventListener('touchstart', (e)=>{ e.preventDefault(); player.lane = Math.max(0, Math.round(player.lane)-1); });
document.getElementById('tright')?.addEventListener('touchstart', (e)=>{ e.preventDefault(); player.lane = Math.min(laneCount-1, Math.round(player.lane)+1); });

// click canvas to start
canvas.addEventListener('click', ()=>{
  if(!running) startGame();
});

// start game function
function startGame(){
  if(running) return;
  // reset if new
  if(!running && score === 0){
    obstacles = [];
    spawnTimer = 0;
    score = 0;
    level = 1;
    speed = 0.9;
    player.lane = Math.floor(laneCount/2);
  }
  running = true;
  paused = false;
  last = 0;
  requestAnimationFrame(loop);
  beep(880,0.06,0.04);
}

// restart
function restartGame(){
  running = false;
  paused = false;
  obstacles = [];
  spawnTimer = 0;
  score = 0;
  level = 1;
  player.lane = Math.floor(laneCount/2);
  scoreEl.textContent = '0';
  levelEl.textContent = '1';
  setTimeout(()=> startGame(), 120);
}

function togglePause(){
  paused = !paused;
  document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
  if(!paused && running){ last = 0; requestAnimationFrame(loop); }
}

function toggleMute(){
  mute = !mute;
  document.getElementById('muteBtn').textContent = mute ? 'Unmute' : 'Mute';
}

// game over overlay
function gameOver(){
  // update highscore
  const s = Math.floor(score);
  if(s > highscore){
    highscore = s;
    localStorage.setItem('tr_high', highscore);
    highEl.textContent = highscore;
  }

  // overlay
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.font = '48px sans-serif';
  ctx.fillText('GAME OVER', W/2, H/2 - 10);
  ctx.font = '18px sans-serif';
  ctx.fillText('Score: ' + s + '  •  High: ' + highscore, W/2, H/2 + 28);
  ctx.font = '14px sans-serif';
  ctx.fillText('Klik Restart untuk main lagi', W/2, H/2 + 64);
  ctx.restore();
}

// prevent touch scroll on canvas
['touchstart','touchmove','touchend','touchcancel'].forEach(t=>{
  canvas.addEventListener(t, e => e.preventDefault(), {passive:false});
});

</script>
</body>
</html>
